<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Â© 2005-2006 Christopher Armstrong.

Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2, as published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled "GNU Free Documentation License".

This documentation is provided on an "AS IS" BASIS, WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND USEFULNESS
OF THE DOCUMENTATION IS WITH YOU (THE LICENSEE). IN NO EVENT WILL THE COPYRIGHT
HOLDERS BE LIABLE FOR DAMAGES, INCLUDING ANY DIRECT, INDIRECT,
SPECIAL, GENERAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF
THE USE OR INABILITY TO USE THIS DOCUMENTATION (INCLUDING BUT NOT
LIMITED TO LOSS OF DATA, USE, OR PROFITS; PROCUREMENT OF SUBSTITUTE
GOODS AND SERVICES; OR BUSINESS INTERUPTION) HOWEVER CAUSED, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -->
<title>eventhandling (Using the GNUstep AppKit 0.1)</title>

<meta name="description" content="eventhandling (Using the GNUstep AppKit 0.1)">
<meta name="keywords" content="eventhandling (Using the GNUstep AppKit 0.1)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="conceptindex.html" rel="index" title="conceptindex">
<link href="index.html" rel="up" title="Top">
<link href="tableview.html" rel="next" title="tableview">
<link href="theviewconcept.html" rel="prev" title="theviewconcept">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="chapter-level-extent" id="eventhandling">
<div class="nav-panel">
<p>
Next: <a href="tableview.html" accesskey="n" rel="next">Tableviews</a>, Previous: <a href="theviewconcept.html" accesskey="p" rel="prev">The view concept</a>, Up: <a href="index.html" accesskey="u" rel="up">Using the GNUstep AppKit</a> &nbsp; [<a href="conceptindex.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h2 class="chapter" id="Event-handling"><span>8 Event handling<a class="copiable-link" href="#Event-handling"> &para;</a></span></h2>

<p>The way events are handled and passed between objects in GNUstep requires special treatment. It is relatively simple, but generally not well documented as to how it works, and how it is used by default in GNUstep. Before reading this chapter, you may wish to reaquaint yourself with views (see <a class="pxref" href="controls.html#The-view-concept">The view concept</a>).
</p>
<p>Event handling can be very complex, or very simple, depending on what your trying to handle and to what extent you&rsquo;re using customised components. We will try to cover some of the basic concepts you may come across in this manual, as well as give a better guide to working with NSResponder and NSEvent.
</p>
<p>We start with the target/action paridigm (which is used to implement outlets/actions in interface files), and then explain the AppKit&rsquo;s underlying event handling model, which is far more powerful and of interest if you are implementing your own views. It&rsquo;s also relevant to understanding how events are passed around in GNUstep (and a recommended read).
</p>
<ul class="mini-toc">
<li><a href="#The-Responder-Chain" accesskey="1">The Responder Chain</a></li>
<li><a href="#Being-a-responder" accesskey="2">Being a responder</a></li>
<li><a href="#Target_002fAction-Paridgm" accesskey="3">Target/Action Paridgm</a></li>
</ul>
<div class="section-level-extent" id="The-Responder-Chain">
<h3 class="section"><span>8.1 The Responder Chain<a class="copiable-link" href="#The-Responder-Chain"> &para;</a></span></h3>

<a class="index-entry-id" id="index-responder"></a>
<a class="index-entry-id" id="index-responder-chain"></a>
<p>A <em class="dfn">responder</em> is an object inheriting from <code class="code">NSResponder</code>. It defines methods that are overrided by subclasses for receiving events, from simple things such as mouse clicks and keyboard presses, to more abstract events such as text selection or text modification. <code class="code">NSView</code> inherits from <code class="code">NSResponder</code> (and in turn <code class="code">NSControl</code> inherits from <code class="code">NSView</code>) so in effect, all views and controls can respond to events.
</p>
<p>Responders are linked together in a chain, whereby a top-level graphical element (usually a window) receives an event, and if it doesn&rsquo;t understand it, it passes it on to higher-level graphical elements, namely views. As views can be placed inside each other, a low-level superview may pass on higher-level events to it&rsquo;s more abstract children. The responder chain is the programmatic linkage between different objects. It is usually setup by GNUstep, but can be modified by the programmer. 
</p>
<p>The object at the top of the focus stack in a window is usually the <em class="dfn">first responder</em>, meaning that any events will be forwarded to it first, and then along the chain if necessary. You can retrieve the first responder in a window by calling <code class="code">-firstResponder</code> against the <code class="code">NSWindow</code> object.<a class="footnote" id="DOCF11" href="#FOOT11"><sup>11</sup></a>.
</p>
<p>More than responder chain may exist, but only one may be active at a time. It is called a chain, due to the way event messages are passed through successive calls to each consecutive object in the chain.
</p>
</div>
<div class="section-level-extent" id="Being-a-responder">
<h3 class="section"><span>8.2 Being a responder<a class="copiable-link" href="#Being-a-responder"> &para;</a></span></h3>

<p>A responder inherits the <code class="code">NSResponder</code> class. As <code class="code">NSView</code> inherits from this, all high-level graphical elements, including all controls and views are considered to be &quot;responders&quot;. This class contains a number of methods for maintaining the the responder chain and default methods for handling certain types of events, such as keyboard, mouse and &quot;text&quot; events (for text-processing classes such as NSText).
</p>
<p>The first method to override is <code class="code">-acceptsFirstResponder</code>, which returns a boolean indicating whether your class will accept first responder status. You can also override <code class="code">-becomeFirstResponder</code> and <code class="code">-resignFirstResponder</code> to be notified of when your class gains and loses the first responder status (respectively).
</p>
<p>The next thing to do is override the different event messages that are predefined in NSResponder, such as <code class="code">-keyDown:</code>, <code class="code">-mouseDragged:</code>, <code class="code">-helpRequested:</code>, etc. What all these have in common is that they take a single <code class="code">NSEvent</code> object argument, which contains information about the event.
</p>
<p>Action messages are messages that have a predefined syntax i.e. they take one object as a parameter, but the name of the method that implements them defines the message. These are passed along the responder chain until a responder implementing that action message is found. This is aided via the <code class="code">-tryToPerform:with:</code> method, which is used by GNUstep to traverse the responder chain and find an object that can perform the <var class="var">anAction</var> selector with <var class="var">anObject</var> as a parameter.
</p>
<p>Some of the common ones include:
</p><ul class="itemize mark-bullet">
<li>-keyDown:
</li><li>-keyUp:
</li><li>-mouseDown:
</li><li>-mouseUp:
</li><li>-mouseMoved:
</li><li>-mouseEntered:
</li><li>-mouseExited:
</li><li>-rightMouseDown:
</li><li>-rightMouseUp:
</li></ul>

<p>You can also pass your own custom selectors along responder chains, trying to find the first object that responds to a particular method name. Given an object and a selector, call <code class="code">-tryToPerform:with:</code> on an object in the responder chain, and this method will be tried on each successive responder until one can be found that responds to the selector. If a method cannot be method, it returns <code class="code">NO</code>.
</p>
</div>
<div class="section-level-extent" id="Target_002fAction-Paridgm">
<h3 class="section"><span>8.3 Target/Action Paridgm<a class="copiable-link" href="#Target_002fAction-Paridgm"> &para;</a></span></h3>

<a class="index-entry-id" id="index-paridgms_002c-Target_002fAction"></a>
<p>Controls use the target/action paridgm for simple events, which only have a sender and a target.<a class="footnote" id="DOCF12" href="#FOOT12"><sup>12</sup></a> The <em class="dfn">target</em> object is the object notified of an event. It is like a <em class="dfn">sink</em> in OLE/COM programming and is referred to as the <em class="dfn">receiver</em>. The <em class="dfn">action</em> is an event being performed, and takes the form of a selector. The <em class="dfn">sender</em> is the object generating the action. An action is passed along the responder chain until it is processed or until the end of the responder chain is reached, in which case the message is returned to the sender indicating it couldn&rsquo;t be processed. Messages that are passed as such events are known as <em class="dfn">action messages</em>, and these events are known as <code class="code">action events</code>.
</p>
<p>Let us explain with a simple example. We create a button on a form as an <code class="code">NSButton</code> that we want to inform our <code class="code">AppController</code> object instance when it is clicked. The button object is the <em class="dfn">sender</em> and the <code class="code">AppController</code> object is the <em class="dfn">target</em>. We tell the button object to call our target object using the selector <code class="code">-browseForServer:</code>.<a class="footnote" id="DOCF13" href="#FOOT13"><sup>13</sup></a> This selector is the <em class="dfn">action</em>.
</p>
<p>Many of these actions are predefined in the <code class="code">NSResponder</code> class which is implemented by all views. 
</p>
<p>On the other hand, things such as menu items define a number of custom such as <code class="code">-save:</code> or <code class="code">-print:</code>, which many, but not all AppKit classes respond to. You can define your own actions for things such as menu buttons.
</p>
<p>Using the above example of a target, sender (which we will call <var class="var">myButton</var>) and action, we could manually setup a link between the objects as follows:
</p><div class="example">
<pre class="example-preformatted">

AppController* appCont;
NSButton* myButton;

// Initialisation of button and target objects

[myButton setAction:@selector(browserForServer:)];
[myButton setTarget:appCont];

</pre></div>

<p>In the above example, whenever <var class="var">myButton</var> is clicked, it will call the <code class="code">invoke:</code> method on the <code class="code">MyButtonTarget</code> instance. What you see above is what Gorm.app does when you connect an action and a target.
</p>
<p>This paradigm is used for simple event handling in classes that derive from NSControl. See see <a class="pxref" href="controls.html#Basic-Controls">Basic Controls</a> and see <a class="pxref" href="applicationmakefiles.html#Interface-Files">Interface Files</a> for more information as to how this fits together.
</p>


</div>
</div>
<div class="footnotes-segment">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT11" href="#DOCF11">(11)</a></h5>
<p>NSWindow objects are responders as well</p>
<h5 class="footnote-body-heading"><a id="FOOT12" href="#DOCF12">(12)</a></h5>
<p>A <em class="dfn">paridgm</em> is a mode of thinking, often applied to programming. You may have heard of the &quot;object-oriented programming pardigm&quot; or the &quot;functional programming&quot; paridgm.</p>
<h5 class="footnote-body-heading"><a id="FOOT13" href="#DOCF13">(13)</a></h5>
<p>The name of the selector is purely arbitrary, and can be anything you like. However, it must take one parameter, which is a reference to the sender object.</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="tableview.html">Tableviews</a>, Previous: <a href="theviewconcept.html">The view concept</a>, Up: <a href="index.html">Using the GNUstep AppKit</a> &nbsp; [<a href="conceptindex.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
